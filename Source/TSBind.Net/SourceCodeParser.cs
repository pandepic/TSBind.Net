using System.Data;
using System.Text;
using System.Xml.Linq;

namespace TSBindDotNet;

public static class SourceCodeParser
{
    private static StringBuilder _typeNameBuilder = new();

    public static string StripReturnTypeName(string typeName)
    {
        typeName = StripGenericType(typeName, "Task");
        typeName = StripGenericType(typeName, "ActionResult");

        // strip out non generic ActionResult
        typeName = typeName.Replace("ActionResult", "void");

        return typeName;
    }

    public static string StripGenericType(string str, string genericTypeName)
    {
        var indexOf = str.IndexOf($"{genericTypeName}<");

        if (indexOf == -1)
            return str;

        str = string.Concat(str.AsSpan(0, indexOf), str.AsSpan(indexOf + $"{genericTypeName}<".Length));
        str = str[..str.LastIndexOf(">")];

        return str;
    }

    public static SourceFileType? FindType(List<ProjectInput> projectInputs, string name)
    {
        foreach (var projectInput in projectInputs)
        {
            var sourceType = projectInput.SourceTypes.Where(c => c.Name == name).FirstOrDefault();
            
            if (sourceType != null)
                return sourceType;
        }

        return null;
    }

    public static SourceFileEnum? FindEnum(List<ProjectInput> projectInputs, string name)
    {
        foreach (var projectInput in projectInputs)
        {
            var sourceEnum = projectInput.SourceEnums.Where(c => c.Name == name).FirstOrDefault();

            if (sourceEnum != null)
                return sourceEnum;
        }

        return null;
    }

    public static void FindReferenceTypes(SourceFileType sourceType, List<string> referenceTypeNames)
    {
        foreach (var field in sourceType.Fields)
            AddReferenceTypeNames(field.TypeName, referenceTypeNames);

        foreach (var property in sourceType.Properties)
            AddReferenceTypeNames(property.TypeName, referenceTypeNames);
    }

    private static void AddReferenceTypeNames(string input, List<string> referenceTypeNames)
    {
        if (!input.Contains("<"))
        {
            referenceTypeNames.AddIfNotContains(input);
            return;
        }

        _typeNameBuilder.Clear();

        foreach (var character in input)
        {
            if (character == '<')
            {
                referenceTypeNames.AddIfNotContains(_typeNameBuilder.ToString().Trim());
                _typeNameBuilder.Clear();
            }
            else if (character == '>')
            {
                referenceTypeNames.AddIfNotContains(_typeNameBuilder.ToString().Trim());
                _typeNameBuilder.Clear();
            }
            else if (character == ',')
            {
                referenceTypeNames.AddIfNotContains(_typeNameBuilder.ToString().Trim());
                _typeNameBuilder.Clear();
            }
            else
            {
                _typeNameBuilder.Append(character);
            }
        }
    }

    public static string TransformTypeName(string typeName)
    {
        typeName = typeName.Replace("List<", "Array<");
        typeName = typeName.Replace("int", "number");
        typeName = typeName.Replace("float", "number");
        typeName = typeName.Replace("decimal", "number");
        typeName = typeName.Replace("bool", "boolean");
        typeName = typeName.Replace("DateTime", "Date");

        if (typeName.EndsWith("?"))
            typeName = typeName[..^1];

        return typeName;
    }

    public static StringBuilder GenerateTS(
        List<string> inputs,
        List<string> includeTypes,
        string generalTemplatePath,
        string apiControllerTemplatePath,
        string apiEndpointTemplatePath)
    {
        var output = new StringBuilder();
        var projectInputs = new List<ProjectInput>();

        output.AppendLine("/* This file was automatically generated by https://github.com/pandepic/TSBind.Net */");
        output.AppendLine();

        var generalTemplate = string.IsNullOrEmpty(generalTemplatePath) ? "" : File.ReadAllText(generalTemplatePath);
        var apiControllerTemplate = File.ReadAllText(apiControllerTemplatePath);
        var apiFunctionTemplate = File.ReadAllText(apiEndpointTemplatePath);

        var referenceTypeNames = new List<string>();
        referenceTypeNames.AddRange(includeTypes);

        foreach (var input in inputs)
            projectInputs.Add(new(input));

        var apiControllers = new List<SourceFileType>();

        foreach (var projectInput in projectInputs)
        {
            apiControllers.AddRange(projectInput.SourceTypes
                .Where(c => c.Attributes.Where(a => a.Name == AttributeNames.ApiController.ToString()).Any()));
        }

        foreach (var controller in apiControllers)
        {
            foreach (var method in controller.Methods)
            {
                referenceTypeNames.AddIfNotContains(StripReturnTypeName(method.ReturnTypeName));

                foreach (var paramType in method.ParameterTypes)
                    referenceTypeNames.AddIfNotContains(paramType);
            }
        }

        var addReferenceTypes = new List<string>();

        foreach (var referenceType in referenceTypeNames)
        {
            var sourceClass = FindType(projectInputs, referenceType);
            if (sourceClass != null)
                FindReferenceTypes(sourceClass, addReferenceTypes);
        }

        referenceTypeNames.AddRangeIfNotContains(addReferenceTypes);

        for (var i = referenceTypeNames.Count - 1; i >= 0; i--)
        {
            var referenceType = referenceTypeNames[i];
            var classType = FindType(projectInputs, referenceType);
            var enumType = FindEnum(projectInputs, referenceType);

            if (classType == null && enumType == null)
                referenceTypeNames.RemoveAt(i);
        }

        var typesOutput = new StringBuilder();

        #region Enums
        foreach (var referenceType in referenceTypeNames)
        {
            var enumType = FindEnum(projectInputs, referenceType);

            if (enumType == null)
                continue;

            typesOutput.AppendLine($"export enum {enumType.Name} {{");

            foreach (var member in enumType.Members)
                typesOutput.AppendLine($"\t{member.Name} = {member.Value},");

            typesOutput.AppendLine("}");

            if (referenceType != referenceTypeNames.Last())
                typesOutput.AppendLine();

            Console.WriteLine($"Generated enum {enumType.Name}");
        }

        typesOutput.AppendLine();
        #endregion

        #region Classes
        foreach (var referenceType in referenceTypeNames)
        {
            var classType = FindType(projectInputs, referenceType);
            if (classType == null)
                continue;

            var outputClassName = classType.Name;

            if (classType.TypeDeclaration.TypeParameterList != null
                && classType.TypeDeclaration.TypeParameterList.Parameters.Count > 0)
            {
                var genericTypes = classType.TypeDeclaration.TypeParameterList.Parameters
                    .Select(p => p.Identifier.ValueText);

                outputClassName += $"<{string.Join(",", genericTypes)}>";
            }

            typesOutput.AppendLine($"export class {outputClassName} {{");

            foreach (var property in classType.Properties)
                typesOutput.AppendLine($"\tpublic {property.Name}?: {TransformTypeName(property.TypeName)};");

            typesOutput.AppendLine("}");

            if (referenceType != referenceTypeNames.Last())
                typesOutput.AppendLine();

            Console.WriteLine($"Generated class {classType.Name}");
        }
        #endregion

        var controllersOutput = new StringBuilder();
        
        foreach (var controller in apiControllers)
        {
            var controllerShortName = controller.Name;
            if (controllerShortName.EndsWith("Controller"))
                controllerShortName = controllerShortName.Substring(0, controllerShortName.LastIndexOf("Controller"));

            var controllerRoute = controller.Attributes.Where(a => a.Name == AttributeNames.Route.ToString()).FirstOrDefault();
            if (controllerRoute == null || controllerRoute.Arguments.Count == 0)
                continue;

            var controllerRouteString = controllerRoute.Arguments[0].Value.Replace("\"", "");
            controllerRouteString = controllerRouteString.Replace("[controller]", controllerShortName);

            var functionsOutput = new StringBuilder();
            var endpointsGenerated = 0;

            foreach (var method in controller.Methods)
            {
                if (method.ParameterTypes.Count == 0)
                    continue;

                var route = method.Attributes.Where(a => a.Name == AttributeNames.Route.ToString()).FirstOrDefault();
                if (route == null || route.Arguments.Count == 0)
                    continue;

                var routeString = controllerRouteString + "/" + route.Arguments[0].Value.Replace("\"", "");

                functionsOutput.AppendLine(apiFunctionTemplate
                    .Replace("{ENDPOINT_NAME}", method.Name)
                    .Replace("{ENDPOINT_ROUTE}", routeString)
                    .Replace("{ENDPOINT_PARAM_TYPE_NAME}", method.ParameterTypes[0])
                    .Replace("{ENDPOINT_RESPONSE_TYPE_NAME}", StripReturnTypeName(method.ReturnTypeName)));

                if (method != controller.Methods.Last())
                    functionsOutput.AppendLine();

                endpointsGenerated++;
            }

            var functionsString = functionsOutput.ToString();

            // remove extra newline at the end
            if (functionsString.EndsWith(Environment.NewLine))
                functionsString = functionsString.Substring(0, functionsString.Length - Environment.NewLine.Length);

            controllersOutput.AppendLine(apiControllerTemplate
                .Replace("{CONTROLLER_SHORT_NAME}", controllerShortName)
                .Replace("{API_FUNCTIONS}", functionsString));

            if (controller != apiControllers.Last())
                controllersOutput.AppendLine();

            Console.WriteLine($"Generated controller {controllerShortName} with {endpointsGenerated} endpoints");
        }
        
        output.AppendLine(
            generalTemplate
                .Replace("{OUTPUT_TYPES}", typesOutput.ToString())
                .Replace("{OUTPUT_CONTROLLERS}", controllersOutput.ToString()));

        return output;
    }
}
